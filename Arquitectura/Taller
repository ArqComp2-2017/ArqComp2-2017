# TALLER ( PRIMER PARCIAL)
### ARQUITECTURA DE COMPUTADORES
#### 2018
###### Jornada Especial.
1. ¿Que es una arquitectura de computadores?
La arquitectura de computadoras es el diseño conceptual y la estructura operacional fundamental de un sistema que conforma una 
computadora. Es decir, es un modelo y una descripción funcional de los requerimientos y las implementaciones de diseño para varias 
partes de una computadora, con especial interés en la forma en que la unidad central de proceso (CPU) trabaja internamente y accede 
a las direcciones de memoria.
“Unidad 1 Introducción a la Arquitectura de Computadoras/ Ing Luis Heriberto Rodríguez Soriana/ Universidad Veracruzana”.

2. Nombre las generaciones de los computadores y sus características más relevantes.
   A)Primera Generación (1946-1954): Denominadas las macrocomputadoras, se caracterizaron por estar integradas de relevadores 
   electromecánicos o de tubos de vacío, eran de gran tamaño, por lo cual ocupaban espaciosos espacios, su capacidad de almacenamiento
   era muy escasa, la entrada de datos era en tarjeta o cinta perforada.
   
   B)	Segunda Generación (1955-1963): En esta generación, se incluyeron los transistores como reemplazo de los tubos de vacío, 
   reduciendo así el tamaño, el calentamiento y uso de energía de las computadoras, se incursiono en el desarrollo de memorias de
   acceso aleatorio mediante núcleos de ferrita y se inició con el uso de cinta magnética, durante esta generación se desarrolló 
   el primer lenguaje de programación de alto nivel.
   
   C)	Tercera Generación (1964-1970): En esta generación se integró a gran escala los transistores en microcircuitos llamados 
   procesadores o círculos integrados monolíticos, así como la proliferación de lenguajes de alto nivel y la introducción de 
   programas que afianzaban la comunicación entre el usuario y la computadora, a lo que se denominó sistema operativo, con esta 
   generación se logró obtener un menor consumo de energía, una relación considerable de espacio, reducción de costos y aumento de 
   capacidad de procesamiento.
   
   D)	Cuarta Generación (1971-1981): El surgimiento del primer microprocesador marca el inicio de esta generación, durante esta
   generación, se obtuvieron importantes avances tecnológicos, el envió del primero correo electrónico utilizando el signo @, se 
   creó el primer mouse, el surgimiento del lenguaje BASIC, aparición de las primeras microcomputadoras a las que se denominó 
   PC, la inclusión de un sistema operativo estandarizado MS-DOS.
   
   E)	Quinta Generación (1982-1995): Se creo la primera supercomputadora con capacidad de proceso paralelo, el desarrollo de la 
   holografía, la nanotecnología, la robótica, las redes neurales, las fibras ópticas, las telecomunicaciones de banda ancha entre 
   otros avances significativos. 

3. Segun Flynn ¿ Cuál es la clasificación de las arquitecturas?
       A) SISD (Simples instrucciones, simples datos).  
       B) SIMD (Simples instrucciones, múltiples datos).
       C) MISD (Múltiples instrucciones, múltiples datos).
       C) MIMD (Multiples instrucciones, múltiples datos).


4. Nombre las clases de aplicaciones de cómputo.
.         Programas Ofimáticos
·         Programas de Diseño
·         Programas de Comunicaciones
·         Programas Multimedia
·         Programas de Edición
·         Programas de Gestión


5. Muestre la clasificación de la jerarquía de un equipo de cómputo.



6. ¿Qué es un compilador?
Un compilador es un programa que traduce de un lenguaje fuente (normalmente un lenguaje de programación de alto nivel, a 
un lenguaje objeto, normalmente código de máquina, es decir un compilador es un traductor. 

7. ¿ Defina qué es una instrucción?

8. ¿Cuales son los principios básicos de diseño de hardware de una arquitectura de cómputo, escriba una definición de cada uno?
-La simplicidad favorece la regularidad.
-Más pequeño es más rápido.
-Hacer que el caso más común sea rápido.
-Buen diseño demanda buenos compromisos.

9. ¿Qué es SPARCV8? 
(Scalable Processor ARChitecture) es una arquitectura de tipo escalable con la que se pueden definir versiones posteriores de la misma
co  mayor cantidad de características siempre salvaguardando la compatiblidad del programa con versiones anteriores.

10. ¿Cuáles son las categorías de instrucciones de la arquitectura SPARCV8?
1) Load/store
2) Arithmetic/logical/shift
3) Control transfer
4) Read/write control register
5) Floating-point operate
6) Coprocessor operate

11. ¿Que tipos de registros se encuentran en SPARC V8?
-in registros de entrada
-local registros locales
-out registros de salida
-global registros globales

12. ¿ Cuál es el número mínimo y máximo de registros que se puede implementar en la arquitectura SPARCV8?
-Número mínimo 2.
-Número máximo 32.

13. ¿ Cuáles son las instrucciones de acceso a memoria de SPARCV8? de un ejemplo de cada uno.
- Load 
  Ejemplo: A[30]   Ld[%O0 + (30*4)], %L0
- Store A[300] = h + A[30]
  add %L1, %L0, %L1
  ST %L1,[%O0 + (300*4)]
  
14. Represente los siguientes números en complemento a 2.
```
	a.5
	b.12890
	c.56900
	d.11
	e.140
```
15. Explique las instrucciones aritmético lógicas y su sintaxis en lenguaje ensamblador.

Las instrucciones Aritmético/Lógicas (SHIFT): son las que ejecutan operaciones aritméticas-logicas y de desplazamiento de bits. 
Estas instrucciones calculan el resultado si es en función de 2 operandos y guardan el resultado si es un registro.

La instrucción en la arquitectura SPARCV8 es [Registro fuente 1, resgitro fuente 2 ó i nmediato, Registro destino]

16. Explique cada uno de los campos de los 3 formatos de la arquitectura SPARC V8.

- Format 1 (op = 1): CALL
  [op disp30]

- Format 2 (op = 0): SETHI & Branches (Bicc, FBfcc, CBccc)
  +Versión 1 [op rd op2 imm22]
  +Versión 2 [op a cond op2 disp22]

- Format 3 (op = 2 or 3): Remaining instructions
  +Versión 1 [op rd op3 rs1 i=0 asi rs2]
  +Versión 2 [op rd op3 rs1 i=1 simm13]
  +Versión 3 [op rd op3 rs1 opf rs2]
  
  Descripción de los campos general:
  -op y op2
       Estos campos de 2 y 3 bits codifican los 3 formatos principales y el formato 2
       instrucciones según los cuadros 5-1 y 5-2 del libro "Manual de la arquitectura SPARC V8).
  -rd
	Este campo de 5 bits es la dirección del destino (o fuente) r o f o coprocesador
	registro (s) para una instrucción de carga / aritmética (o almacenamiento). Para una instrucción
	que lee / escribe un doble (o cuádruple), los bits menos significativos (o dos) son
	no utilizado y debe ser proporcionado como cero por el software.
  -cond
	Este campo de 4 bits selecciona los códigos de condición para probar una instrucción de bifurcación.

  - imm22
	Este campo de 22 bits es una constante que SETHI coloca en el extremo superior de un destino.
  -disp22 y disp30
	Estos campos de 30 bits y 22 bits están alineados con las palabras, con extensión de signo, relativos a la PC
	desplazamientos para una llamada.
  -op3
	Este campo de 6 bits (junto con 1 bit de op) codifica las instrucciones de formato 3.
  -i
	El bit i selecciona el segundo operando ALU para aritmética y las instrucciones (entera) y load / store . Si i = 0, el 
	operando es r [rs2]. Si i = 1, el operando es simm13, con extensión de signo de 13 a 32 bits.
	
17. ¿Qué diferencia hay entre el campo **op, op2 y op3**?

18. ¿Qué es **PSR** ?, explique cada uno de sus campos.

19. ¿ Qué es **ICC** y **CWP**?

20. ¿Qué es una instrucción sintética, de dos ejemplos?

21. ¿Qué significa el campo **a** para una instrucción BRANCH?.

22. ¿Para qué la instrucción **CALL** utiliza el registro %O7?.

23. Convertir el siguiente programa en lenguaje de máquina a lenguaje ensamblador y luego a lenguaje de alto nivel:
```
10100000000100000010000000000101
10100010000100000011111111111010
10010000000001000100000000010000
```
24.Solucione el siguiente programas en lenguaje ensamblador, lenguaje de máquina y hexadecimal, además coloque su dirección de memoria.
```c
int main(){
	int i = 5; 
	int b = -4;
	int c[100];
	int d[20];
	c[5] = i + 2;
	d[4] = b + 3;
	return c[5] + d[4] -i
}
```

25. Convierta el siguiente código a lenguaje ensamblador, máquina **SPARC V8** y hexadecimal.
a.
 ```c
 int main(){
 int a = 8;
 int b = -14800;
 int c = 33; 
 if((a+b)<=b*16){
 	c=a+(b*2);
	}
else{
	return b-78;
}
	return a+c;
}
 ```

b.
 ```c
int main(){
	int a = 8;
	int b = -10;
	if(a!=b){
		return c/16;
	}
	else{
		return b*32;
	}
}
```
c.

 ```c
int main(){
	int a = -21180;
}
```

26. Convierta el siguiente código a lenguaje ensamblador, máquina **SPARC V8** y hexadecimal.
 ```c
int test(int x, int y, int w){
	int z;
	z = x - y + w*4;
	return z + 2;
}

int main(){
	int a = 4, b = 2, c = -15600;
	int x = test(a,b,c);
	return x + 45;
}
 ```

27. Implemente la función **Pot** en lenguaje de alto nivel,lenguaje ensamblador **SPARC V8** y lenguaje de máquina SPARC V8 que realice la potencia de dos números enteros sin signo realizando llamados a la función multiplicacion hecha en clase.
	multiplicación
0000	MOV 0; % L0
0004	MOV 1; % O0
	I´m for
0008	CMP %L0, % i1
000C	BGE a No mas for
0010	SLL %O0 , i0; O0
0014	BA I´m in for
0018	ADD %L0, 1, %L0
	No mas for
001C	JMPL %07, 8, % g0
0020	Nop
	MAIN
0024	MOV 5, % i0
0028	MOV 3, % i1
002C	call Multiplicación
0030	Nop
0034	Mov 0, %O1

28. Implemente una función **Fact** en lenguaje de alto nivel, lenguaje ensamblador **SPARC V8** y lenguaje de máquina SPARC V8 que calcule el factorial de un número entero sin signo.

29. Hacer el nPC Y PC en VHDL. 
